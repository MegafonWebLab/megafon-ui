# Архитектура

`megafon-ui` - библиотека под управлением [Lerna](https://github.com/lerna/lerna).

Директория `packages` включает несколько пакетов, которые публикуются в `npm` с независимыми версиями.

В корневой `package.json` добавлены скрипты для выполнения команд в каждом из пакетов.
Например, запуск `yarn run build` последовательно запустит `build`-скрипты в каждом из пакетов из директории `packages`.


# Разработка

Для внесения изменений в библиотеку необходимо форкнуть репозиторий, создать в своей копии ветку и после
внесения изменений создать pull request в главный репозиторий.

Разработка ведется на языке TypeScript. Новые компоненты должны быть функциональными.
Параметры по умолчанию задавать при деструктуризации в аргументе компонента.
```jsx
const ComponentName = ({ name = 'name' }) => ...
```

Для каждого компонента должна быть создана своя директория со следующим содержимым:

1. `<Component name>.tsx` с кодом компонента
2. `<Component name>.less` для стилей
3. `<Component name>.test.tsx` для тестов. Все пропсы должны быть
протестированы: колбэки с помощью моков, остальные пропсы через снепшоты.
4. Директория `doc`, включающая документацию в формате [Docz](https://github.com/doczjs/docz):
    - `<Component name>.mdx` - корневая страница документации для компонента, должна содержать компонент DoczTabs
    - `<Component name>.example.mdx` - файл с примерами использования компонента
    - `<Component name>.props.mdx` - для контента вкладки с таблицей пропсов
    - `<Component name>.design.mdx` - дизайнерская документация
    - `<Component name>.docz.tsx` - исходники для примеров, например для кода оберток или дополнительных стилей

Тесты и линтеры можно запустить с помощью команд:

```bash
$ yarn run lint
```

```bash
$ yarn run test
```

Тесты и линтеры также автоматически запускаются перед каждым коммитом.

Перед запуском тестов необходимо собрать проект через `yarn run build`, т.к. если проект не будет собран, то
возникнет проблема с зависимостями между пакетами.


## Как сделать коммит

На проекте используются [conventional commits](https://www.conventionalcommits.org/ru/v1.0.0-beta.4/).
Более прикладное описание можно подсмотреть тут: https://github.com/angular/angular/blob/master/CONTRIBUTING.md#-commit-message-format

Сообщение каждого коммита должно описывать:

- тип, т.е. какой уровень изменений привнесет влитие коммита (например: feat, fix, ci или docs)
- scope (контекст) изменений (например, какой-то компонент)
- описание изменений, которые будут зафиксированы отдельной строкой в changelog-е.

*Примеры типов по семверу:*

```
patch: fix(button): new prop onClick
minor: feat(incredible-component): added new component
major:

feat(button): deprecated onClick prop removed

BREAKING CHANGE: onClick prop removed
```

Для упрощения создания коммитов в зависимости добавлен commitizen, с ним коммит можно делать так:

```
git add .
git cz
```

После запуска cz запустится wizard, который задаст необходимые параметры сообщения. На одном из шагов
нужно отметить тикер задачи, к которой относятся правки.

Если после попытки коммита что-то пошло не так (например коммит был прерван из-за ошибок линтера), то
чтобы не вводить параметры коммита заново, можно воспользоваться командой git cz --retry.


### Типы коммитов

Основные - это fix и feat для патча и минорного изменения соответственно. Они будут использоваться в 99% случаев.
Breaking changes могут появиться внутри любого из них (либо с другим типом), тогда при влитии будет опубликована
следующая мажорная версия. Это должен быть редкий случай. Другие типы можно подсмотреть в доке для [angular](https://github.com/angular/angular/blob/master/CONTRIBUTING.md#-commit-message-format).


### Что попадет в changelog

Сообщения из коммитов с типом `feat`, `fix`, `perf`, а также все коммиты помеченные как `breaking change` с любым типом попадают в changelog.


### Добавление коммитов в существующую ветку

Если в ветке уже есть коммит с типом, попадающим в генерацию changelog'а, то можно добавить новые
коммиты с типом `refactor`, чтобы они не были добавлены в changelog.


## Ревью

В процессе ревью необходимо проверять сообщения в коммитах на предмет соответствия
правок в реквесте. Если сообщения несоответствуют правкам в коде - необходимо вернуть реквест на доработку.

Особое внимание должно уделяться `breaking change` - в интерфейсе github'а в сообщении коммита эта строка не видна
и при просмотре будет необходимо раскрывать сообщения коммитов, они свернуты под иконкой троеточия.

## Публикация пакетов

Публикация происходит автоматически при коммите в ветку `master` с помощью Github Actions. Lerna по сообщениям из коммитов определяет
следующую релизную версию, генерирует changelog и при наличии изменений в коде публикует пакеты в npm.

### Как пропустить публикацию

Чтобы не публиковать новый пакет нужно в сообщение коммита добавить строку `skip release`.
Сообщение должно быть в последнем коммите, загруженном в репозиторий, например:

1. если пушнуть 2 коммита одновременно, `skip release` должен быть в последнем коммите, в первом не обязательно
2. если нужно влить ветку без публикации, в поле сообщения в интерфейсе github'а нужно добавить `skip release`

Добавленные изменения попадут в релиз при следующем коммите в мастер, если у него не будет `skip release` в сообщении.

## Переход от пререлизной версии к основной:

1. в `lerna.json` удалить строки с `distTag`, `conventionalPrerelease`, `preid`
2. в `lerna.json` вместо удаленных добавить `conventionalGraduate="*"``
3. влить в мастер, дождаться прохода пайплайна и публикации пакетов
4. следующим коммитом можно удалить `conventionalGraduate="*"`` (если не удалять, он все равно будет игнорироваться)
