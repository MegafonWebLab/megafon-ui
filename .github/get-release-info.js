#!/usr/bin/env node
const execSync = require('child_process').execSync;
const fs = require('fs');

/**
 * Gets envs.
 *
 * @returns {
 *     prNumber: number,
 *     baseSha: string,
 *     headSha: string,
 *     oldBody?: string,
 * }
 */
const getEnvs = () => {
    const { PULL_REQUEST_NUMBER, BASE_SHA, HEAD_SHA, PULL_REQUEST_BODY } = process.env;

    console.log('::group::Provided envs:');
    console.log("\n\tPULL_REQUEST_NUMBER:", `'${PULL_REQUEST_NUMBER}'`, "\n\tBASE_SHA:", `'${BASE_SHA}'`, "\n\tHEAD_SHA:", `'${HEAD_SHA}'`, "\n\tPULL_REQUEST_BODY:", `'${PULL_REQUEST_BODY}'`);
    console.log('::endgroup::');

    if (PULL_REQUEST_NUMBER === undefined || !BASE_SHA || !HEAD_SHA) {
        throw new Error('Not enough info to make checks.');
    }

    return {
        prNumber: PULL_REQUEST_NUMBER,
        baseSha: BASE_SHA,
        headSha: HEAD_SHA,
        oldBody: PULL_REQUEST_BODY,
    };
};

const extractVersions = () => {
    const res = execSync(`git diff HEAD --unified=0 --no-prefix --relative='packages' '*package.json'`).toString();
    const strs = res.split('\n');

    let versions = '';
    for (const s of strs) {
        if (s.includes('+++')) {
            const packageName = s.match(/\s(.*)$/)[1];
            if (versions.length > 0) {
                versions += '\n\n';
            }
            versions += `${packageName}`;
        }
        if (s.includes('version')) {
            versions += `\n${s.substring(3, s.length - 1)}`;
        }
    }

    return versions;
}

const extractChangelogs = () => {
    const res = execSync(`git diff HEAD --unified=0 --no-prefix -- '*CHANGELOG.md'`).toString();

    const strs = res.split('\n');

    let changelogs = '';
    for(const s of strs) {
        if (s.startsWith('+++')) {
            changelogs += `## :memo: ${s.substr(4)}\n`;

            continue;
        }

        if (s.startsWith('+')) {
            changelogs += s.substr(1) + '\n';
        }
    }

    return changelogs;
};

const getOriginalBody = (oldBody) => {
    let originalBody;
    if (oldBody?.includes('<!-- Autogenerated checksum:')) {
        originalBody = oldBody.split('<!-- Autogenerated checksum:')[0];
    } else {
        originalBody = oldBody || '';
    }

    return originalBody;
}

const composeNewDescription = (oldBody, checkSum, versions, changelogs) => {
    const originalBody = getOriginalBody(oldBody);

    let result = `${originalBody}<!-- Autogenerated checksum:${checkSum} -->\n\n\n---\n## Upcoming release changes\n> New commits in branch will trigger this description update.\n\n`;

    if (versions) {
        result += `### Version updates:\n\`\`\`\n${versions}\n\`\`\`\n`;
    } else {
        result += `### Version updates:\nNo version changes detected.\n`;
    }

    if (changelogs) {
        result += `### Changelogs:\n${changelogs}`;
    } else {
        result += `### Changelogs:\nNo updates detected.\n`;
    }

    return result;
}

const start = async () => {
    const envs = getEnvs();

    const checkSum = `${envs.baseSha}_${envs.headSha}`;
    const lastChecksum = envs.oldBody?.match(/<!-- Autogenerated checksum:(.*) -->/);
    if (lastChecksum && lastChecksum.length > 0 && lastChecksum[1] === checkSum) {
        console.log(`Pull request description doesn't need to be updated.`);

        process.exit(0);
    } else {
        console.log(`Generating pull request description...`);

        const tempMergeBranchName = 'this-pr-merge-branch';
        execSync(`git switch -c ${tempMergeBranchName}`);
        execSync(`yarn exec lerna version -- --allow-branch=${tempMergeBranchName} --conventional-commits --no-git-tag-version --no-push --yes`);

        const versions = extractVersions();
        const changelogs = extractChangelogs();

        const releaseInfo = composeNewDescription(envs.oldBody, checkSum, versions, changelogs);

        try {
            fs.writeFileSync(`./release-info-${envs.prNumber}.txt`, releaseInfo);
        } catch (err) {
            console.error('Exception while writing results to file:', err);
        }

        console.log(`Pull request description generated.`);
    }
};

try {
    start();
} catch(ex) {
    console.log('Exception:', ex);
}
